
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Comprehensive Guide to Java HashSet</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            margin: 40px;
            background: #f9f9f9;
            color: #333;
        }
        h1, h2, h3 {
            color: #0a4c76;
        }
        code, pre {
            background: #f4f4f4;
            padding: 10px;
            border-left: 4px solid #0a4c76;
            display: block;
            white-space: pre-wrap;
            font-family: Consolas, monospace;
        }
        .note {
            background: #e1f5fe;
            padding: 10px;
            margin: 10px 0;
            border-left: 5px solid #0288d1;
        }
        ul {
            margin-left: 20px;
        }
    </style>
</head>
<body>
    <h1>Java HashSet - Comprehensive Review</h1>

    <h2>What is a HashSet?</h2>
    <p>
        A <code>HashSet</code> is a collection in Java that implements the <code>Set</code> interface and uses a hash table for storage.
        It does not allow duplicate elements and provides constant-time performance for basic operations like add, remove, and contains, assuming the hash function disperses elements properly.
    </p>

    <h2>Key Characteristics</h2>
    <ul>
        <li><strong>No index access:</strong> You cannot get elements by index.</li>
        <li><strong>No order guarantee:</strong> HashSet does not maintain insertion order.</li>
        <li><strong>Unique elements only:</strong> Based on <code>hashCode()</code> and <code>equals()</code>.</li>
    </ul>

    <h2>Time Complexities</h2>
    <ul>
        <li><code>add(E e)</code>: O(1) on average, O(n) in worst case due to collisions</li>
        <li><code>remove(Object o)</code>: O(1) on average, O(n) worst case</li>
        <li><code>contains(Object o)</code>: O(1) on average</li>
    </ul>

    <div class="note">
        <strong>Note:</strong> Starting from Java 8, when collisions increase beyond a threshold (default 8), buckets convert from LinkedList to a Binary Tree to improve lookup time from O(n) to O(log n).
    </div>

    <h2>How HashSet Works Internally</h2>
    <ol>
        <li>Each element is hashed using <code>hashCode()</code>.</li>
        <li>Hash value is modded by the table size to find a bucket.</li>
        <li>Collision handling uses a LinkedList or Tree (after Java 8).</li>
        <li>Before adding an element, the set checks all elements in the bucket using <code>equals()</code>.</li>
    </ol>

    <h2>Example Usage</h2>
    <pre><code>import java.util.HashSet;

public class HashSetDemo {
    public static void main(String[] args) {
        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
        set.add("A");
        set.add("B");
        set.add("C");
        set.add("A"); // duplicate

        System.out.println(set); // [A, B, C]
        System.out.println("Contains A? " + set.contains("A")); // true
        set.remove("B");
        System.out.println(set); // [A, C]
    }
}
    </code></pre>

    <h2>Common Interview Points</h2>
    <ul>
        <li><strong>hashCode()</strong> and <strong>equals()</strong> are essential for uniqueness.</li>
        <li>Collisions happen when two elements have same bucket index.</li>
        <li>Good hashCode implementations minimize collisions.</li>
        <li>Treeification helps prevent performance degradation.</li>
    </ul>

    <h2>Drawbacks</h2>
    <ul>
        <li>Not synchronized â€” use <code>Collections.synchronizedSet()</code> if thread-safe access is required.</li>
        <li>Iteration order is not guaranteed.</li>
        <li>More memory usage compared to lists.</li>
    </ul>

    <footer style="margin-top: 40px; font-size: 0.9em; color: #777;">
        &copy; 2025 HashSet Review by ChatGPT
    </footer>
</body>
</html>
