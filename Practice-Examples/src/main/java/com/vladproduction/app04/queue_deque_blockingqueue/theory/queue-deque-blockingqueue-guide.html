<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Java Queue, Deque, and BlockingQueue Guide</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background: #f4f4f4;
        }
        h1, h2, h3 {
            color: #333;
        }
        pre {
            background: #eee;
            padding: 10px;
            border-left: 4px solid #333;
            overflow-x: auto;
        }
        code {
            background: #e0e0e0;
            padding: 2px 4px;
            font-family: monospace;
        }
        .section {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>

<h1>Java Queue, Deque, and BlockingQueue Guide</h1>

<div class="section">
    <h2>1. Queue Interface</h2>
    <p>The <code>Queue</code> interface in Java (java.util.Queue) is a collection designed for holding elements prior to processing. It follows a FIFO (First-In-First-Out) order.</p>

    <h3>Common Implementations:</h3>
    <ul>
        <li><code>LinkedList</code></li>
        <li><code>PriorityQueue</code></li>
        <li><code>ArrayDeque</code> (implements both Queue and Deque)</li>
    </ul>

    <h3>Main Methods:</h3>
    <ul>
        <li><code>add(e)</code> – inserts the element, throws exception on failure</li>
        <li><code>offer(e)</code> – inserts the element, returns false if fails</li>
        <li><code>remove()</code> – removes and returns the head</li>
        <li><code>poll()</code> – removes and returns head or null if empty</li>
        <li><code>element()</code> – retrieves head, throws exception if empty</li>
        <li><code>peek()</code> – retrieves head or null if empty</li>
    </ul>

    <h3>Example:</h3>
    <pre><code>Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();
queue.offer("A");
queue.offer("B");
System.out.println(queue.poll()); // A
System.out.println(queue.peek()); // B</code></pre>
</div>

<div class="section">
    <h2>2. Deque Interface</h2>
    <p>The <code>Deque</code> interface (java.util.Deque) stands for "double-ended queue" and allows element insertion and removal from both ends.</p>

    <h3>Common Implementations:</h3>
    <ul>
        <li><code>ArrayDeque</code></li>
        <li><code>LinkedList</code></li>
    </ul>

    <h3>Main Methods:</h3>
    <ul>
        <li><strong>Front:</strong> <code>addFirst(e)</code>, <code>offerFirst(e)</code>, <code>removeFirst()</code>, <code>pollFirst()</code>, <code>getFirst()</code>, <code>peekFirst()</code></li>
        <li><strong>Rear:</strong> <code>addLast(e)</code>, <code>offerLast(e)</code>, <code>removeLast()</code>, <code>pollLast()</code>, <code>getLast()</code>, <code>peekLast()</code></li>
    </ul>

    <h3>Example:</h3>
    <pre><code>Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();
deque.addFirst("A");
deque.addLast("B");
System.out.println(deque.pollFirst()); // A
System.out.println(deque.pollLast());  // B</code></pre>
</div>

<div class="section">
    <h2>3. BlockingQueue Interface</h2>
    <p><code>BlockingQueue</code> is part of the java.util.concurrent package. It's designed for producer-consumer scenarios. It blocks threads trying to add elements to a full queue or take elements from an empty queue.</p>

    <h3>Common Implementations:</h3>
    <ul>
        <li><code>ArrayBlockingQueue</code> – fixed capacity</li>
        <li><code>LinkedBlockingQueue</code> – optionally bounded</li>
        <li><code>PriorityBlockingQueue</code> – with priority ordering</li>
        <li><code>DelayQueue</code>, <code>LinkedTransferQueue</code>, <code>SynchronousQueue</code></li>
    </ul>

    <h3>Main Methods:</h3>
    <ul>
        <li><code>put(e)</code> – blocks if full</li>
        <li><code>take()</code> – blocks if empty</li>
        <li><code>offer(e, timeout, unit)</code></li>
        <li><code>poll(timeout, unit)</code></li>
    </ul>

    <h3>Example:</h3>
    <pre><code>BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(2);
queue.put("A");
queue.put("B");
// queue.put("C"); // blocks until space available
System.out.println(queue.take()); // A</code></pre>
</div>

<div class="section">
    <h2>4. Comparison Table</h2>
    <table border="1" cellpadding="10" cellspacing="0">
        <tr>
            <th>Feature</th>
            <th>Queue</th>
            <th>Deque</th>
            <th>BlockingQueue</th>
        </tr>
        <tr>
            <td>FIFO</td>
            <td>Yes</td>
            <td>Optional</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>Thread-safe</td>
            <td>No</td>
            <td>No</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>Insertion ends</td>
            <td>One</td>
            <td>Both</td>
            <td>One (usually)</td>
        </tr>
        <tr>
            <td>Blocking methods</td>
            <td>No</td>
            <td>No</td>
            <td>Yes</td>
        </tr>
    </table>
</div>

<div class="section">
    <h2>5. Summary</h2>
    <ul>
        <li><strong>Use Queue</strong> for simple FIFO data structures.</li>
        <li><strong>Use Deque</strong> when you need stack/queue hybrid behavior.</li>
        <li><strong>Use BlockingQueue</strong> for producer-consumer and thread-safe operations.</li>
    </ul>
</div>

</body>
</html>