1. Чем отличается ArrayList от LinkedList?

ArrayList это список, реализованный на основе массива, а LinkedList — это классический
связный список, основанный на объектах с ссылками между ними.

Преимущества ArrayList: в возможности доступа к произвольному элементу по индексу за постоянное время
(так как это массив), минимум накладных расходов при хранении такого списка, вставка в конец списка в
среднем производится так же за постоянное время. В среднем потому, что массив имеет определенный начальный
размер n (в коде это параметр capacity), по умолчанию n = 10, при записи n+1 элемента, будет создан новый
массив размером (n * 3) / 2 + 1, в него будут помещены все элементы из старого массива + новый, добавляемый
элемент. В итоге получаем, что при добавлении элемента при необходимости расширения массива, время добавления
будет значительно больше, нежели при записи элемента в готовую пустую ячейку. Тем не менее, в среднем время
вставки элемента в конец списка является постоянным. Удаление последнего элемента происходит за константное
время. Недостатки ArrayList проявляются при вставке/удалении элемента в середине списка — это взывает
перезапись всех элементов размещенных «правее» в списке на одну позицию влево, кроме того, при удалении
элементов размер массива не уменьшается, до явного вызова метода trimToSize().

LinkedList наоборот, за постоянное время может выполнять вставку/удаление элементов в списке (именно вставку
и удаление, поиск позиции вставки и удаления сюда не входит). Доступ к произвольному элементу осуществляется
за линейное время (но доступ к первому и последнему элементу списка всегда осуществляется за константное
время — ссылки постоянно хранятся на первый и последний, так что добавление элемента в конец списка вовсе
не значит, что придется перебирать весь список в поисках последнего элемента). В целом же, LinkedList в
абсолютных величинах проигрывает ArrayList и по потребляемой памяти и по скорости выполнения операций.
LinkedList предпочтительно применять, когда происходит активная работа (вставка/удаление) с серединой
списка или в случаях, когда необходимо гарантированное время добавления элемента в список.


2. Что вы обычно используете (ArrayList или LinkedList)? Почему?

В 90% случае ArrayList будет быстрее и экономичнее LinkedList, так что обычно используют ArrayList, но тем
не менее всегда есть 10% случаев для LinkedList. ArrayList использую, ссылаясь на тесты и
последний абзац из предыдущего вопроса, но не забываю и про LinkedList (в каких случаях? так же последний абзац
предыдущего вопроса помогает).



3. Что быстрее работает ArrayList или LinkedList?

Встречный вопрос о том, какие действия будут выполняться над структурой? В итоге, ответ возможен из вопроса 1.



4. Необходимо добавить 1млн. элементов, какую структуру вы используете?

Информации для однозначного выбора нет. Нужно задавать дополнительные вопросы: в какую часть списка происходит
добавление элементов? есть ли информация о том, что потом будет происходить с элементами списка? какие то
ограничения по памяти или скорости выполнения? В целом, все тот же первый вопрос, но немного с другой стороны:
через дополнительные вопросы, можно показать глубину понимания работы Array и Linked List.



5. Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?

Опять же, ответ на вопрос 1 содержит ответ и на этот вопрос. При удалении произвольного элемента из списка,
все элементы находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость,
capacity) не изменяется никак. Механизм автоматического «расширения» массива существует, а вот автоматического
 «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize().



6. Предложите эффективный алгоритм удаления нескольких рядом стоящих элементов из середины списка,
реализуемого ArrayList.

Допустим нужно удалить n элементов с позиции m в списке. Вместо выполнения удаления одного элемента n раз
(каждый раз смещая на 1 позицию элементы, стоящие «правее» в списке), нужно выполнить смещение всех элементов,
стоящих «правее» n+m позиции на n элементов левее к началу списка. Таким образом, вместо выполнения n итераций
перемещения элементов списка, все выполняется за 1 проход.



7. Как устроена HashMap?

Вкратце, HashMap состоит из «корзин» (bucket`ов). С технической точки зрения «корзины» — это элементы массива,
которые хранят ссылки на списки элементов. При добавлении новой пары ключ-значение, вычисляет хеш-код ключа,
на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент.
Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент,
то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего
элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент
с таким же ключом, то он заменяется. Добавление, поиск и удаление элементов выполняется за константное
время. Вроде все здорово, с одной оговоркой, хеш-функций должна равномерно распределять элементы по
корзинам, в этом случае временная сложность для этих 3 операций будет не ниже lg N, а в среднем случае
как раз константное время.



8. Какое начальное количество корзин в HashMap?

Ответ здесь — 16. Отвечая, стоит заметить, что можно используя конструкторы с параметрами: через параметр
capacity задавать свое начальное количество корзин.



9. Какая оценка временной сложности выборки элемента из HashMap? Гарантирует ли HashMap указанную сложность
выборки элемента?

На самом деле ответ следует из ответа вопроса 7.
Если вы возьмете хеш-функцию, которая постоянно будет возвращать одно и то же значение, то HashMap превратится
в связный список, с отвратной производительностью. Затем даже, если вы будете использовать хеш-функцию с
равномерным распределением, в предельном случае гарантироваться будет только временная сложность lg N.
Так что, ответ на вторую часть вопроса — нет, не гарантируется.



10. Роль equals и hashCode в HashMap?

Ответ на этот вопрос следует из ответа на вопрос 7, хотя явно там и не прописан. hashCode позволяет
определить корзину для поиска элемента, а equals используется для сравнения ключей элементов в списке
внутри корзины и искомого ключа.



11. Максимальное число значений hashCode()?

Здесь все довольно просто, достаточно вспомнить сигнатуру метода: int hashCode(). То есть число значений
равно диапазону типа int — 2^32.



12. Как и когда происходит увеличение количества корзин в HashMap?

Помимо capacity в HashMap есть еще параметр loadFactor, на основании которого, вычисляется предельное
количество занятых корзин (capacity*loadFactor). По умолчанию loadFactor = 0,75. По достижению предельного
значения, число корзин увеличивается в 2 раза. Для всех хранимых элементов вычисляется новое «местоположение»
с учетом нового числа корзин.



13. В каком случае может быть потерян элемент в HashMap?

Допустим в качестве ключа используется не примитив, а объект с несколькими полями.
После добавления элемента в HashMap у объекта, который выступает в качестве ключа, изменяют одно поле,
которое участвует в вычислении хеш-кода. В результате при попытке найти данный элемент по исходному ключу,
будет происходить обращение к правильной корзине, а вот equals (ведь equals и hashCode должны работать с
одним и тем же набором полей) уже не найдет указанный ключ в списке элементов. Тем не менее, даже если
equals реализован таким образом, что изменение данного поля объекта не влияет на результат, то после
увеличения размера корзин и пересчета хеш-кодов элементов, указанный элемент, с измененным значением поля,
с большой долей вероятности попадет совсем в другую корзину и тогда он уже совсем потеряется.

14. Почему нельзя использовать byte[] в качестве ключа в HashMap?

Хеш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива
(метод вычисления хеш-кода массива не переопределен и вычисляется по стандартному Object.hashCode()
на основании адреса массива). Так же у массивов не переопределен equals и выполняет сравнение указателей.
Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании
другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае —
при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.



15. В чем отличия TreeSet и HashSet?

Set — это множество (так же называют «набором»). Set не допускает хранение двух
одинаковых элементов. Формально говоря, термин «множество» и так обозначает совокупность различных
элементов, очень важно, что именно различных элементов, так как это главное свойство Set. С учетом
такого определения, пояснение про хранение одинаковых элементом не требуется, но в обиходе, понятие
«множество» потеряло свой строгий смысл касательно уникальности элементов, входящих в него, поэтому
все же уточняйте отдельно данное свойство множества.

TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения
основных операций в TreeSet lg N. HashSet использует для хранения элементов такой же подход, что и
HashMap, за тем отличием, что в HashSet в качестве ключа выступает сам элемент, кроме того HashSet
(как и HashMap) не поддерживает упорядоченное хранение элементов и обеспечивает временную сложность
выполнения операций аналогично HashMap.

16. Устройство TreeSet?

TreeSet основан на красно-черном дереве.



17. Что будет, если добавлять элементы в TreeSet по возрастанию?

Если нет точного представления об устройстве TreeSet, а есть общее понимание о том, что это бинарное
дерево (в чем нас дополнительно уверяет собеседник, возможно), то данный вопрос может привести к интересному
результату: все элементы после доабвления в обычное бинарное дерево будут находится в одной ветви
длиной N элементов, что сводит на нет, все преимущества такой структуры, как дерево (фактически получается
список). На самом, деле, как выше упоминалось в основе TreeSet лежит красно-черное дерево, которое умеет
само себя балансировать. В итоге, TreeSet все равно в каком порядке вы добавляете в него элементы,
преимущества этой структуры данных будут сохраняться.