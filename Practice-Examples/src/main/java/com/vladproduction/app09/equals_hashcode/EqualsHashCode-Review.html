<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>equals() and hashCode() in Java - Comprehensive Guide</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --bg-light: #f8f9fa;
            --text-dark: #333;
            --code-bg: #f1f3f5;
            --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --success-color: #2ecc71;
            --warning-color: #e74c3c;
        }

        body {
            font-family: 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.7;
            color: var(--text-dark);
            margin: 0;
            padding: 0;
            background-color: var(--bg-light);
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 30px 0;
            text-align: center;
            margin-bottom: 30px;
            border-radius: 0 0 10px 10px;
        }

        header h1 {
            margin: 0;
            font-size: 2.4rem;
        }

        header p {
            margin: 10px 0 0;
            font-size: 1.2rem;
            opacity: 0.9;
        }

        h1, h2, h3, h4 {
            color: var(--primary-color);
            margin-top: 1.8em;
            margin-bottom: 0.8em;
        }

        h2 {
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 8px;
        }

        .icon {
            margin-right: 8px;
            color: var(--accent-color);
        }

        code {
            background-color: var(--code-bg);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 0.95em;
        }

        pre {
            background-color: var(--code-bg);
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid var(--accent-color);
            margin: 20px 0;
        }

        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        ul, ol {
            margin-left: 20px;
            padding-left: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: var(--card-shadow);
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: var(--accent-color);
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.03);
        }

        .card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: var(--card-shadow);
        }

        .two-columns {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }

        .two-columns > div {
            flex: 1;
            min-width: 300px;
        }

        .example {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: var(--card-shadow);
        }

        .example-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--accent-color);
        }

        .note {
            background-color: #e7f2fa;
            border-left: 5px solid var(--accent-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .warning {
            background-color: #fdecea;
            border-left: 5px solid var(--warning-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .success {
            background-color: #e8f8f2;
            border-left: 5px solid var(--success-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .faq {
            margin-bottom: 15px;
        }

        .question {
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 5px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: var(--card-shadow);
            transition: all 0.3s ease;
        }

        .question:hover {
            background-color: #f0f7fc;
        }

        .answer {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 0 0 5px 5px;
            margin-top: -5px;
            margin-bottom: 15px;
            border: 1px solid #eee;
        }

        .toc {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            box-shadow: var(--card-shadow);
        }

        .toc ul {
            list-style-type: none;
            padding-left: 15px;
        }

        .toc a {
            text-decoration: none;
            color: var(--accent-color);
        }

        .toc a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .two-columns > div {
                flex: 100%;
            }
        }
    </style>
</head>
<body>

<header>
    <div class="container">
        <h1>equals() and hashCode() in Java</h1>
        <p>A comprehensive guide for developers and interview preparation</p>
    </div>
</header>

<div class="container">
    <div class="toc">
        <h3>üìã Table of Contents</h3>
        <ul>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#equals-method">The equals() Method</a></li>
            <li><a href="#hashcode-method">The hashCode() Method</a></li>
            <li><a href="#relationship">Relationship Between equals() and hashCode()</a></li>
            <li><a href="#implementation">Proper Implementation</a></li>
            <li><a href="#collections">Impact on Collections</a></li>
            <li><a href="#common-mistakes">Common Mistakes</a></li>
            <li><a href="#best-practices">Best Practices</a></li>
            <li><a href="#interview-questions">Interview Questions</a></li>
            <li><a href="#code-examples">Code Examples</a></li>
        </ul>
    </div>

    <section id="introduction">
        <h2>üöÄ Introduction</h2>
        <p>The <code>equals()</code> and <code>hashCode()</code> methods are fundamental to Java's object equality model and are critical for the proper functioning of many Java collections. Understanding these methods is essential for Java developers and is a common topic in technical interviews.</p>

        <div class="two-columns">
            <div class="card">
                <h3>equals()</h3>
                <p>Determines if two objects are <strong>logically equivalent</strong>. The default implementation in <code>Object</code> class uses reference equality (==), but you can override it to define what makes instances of your class equal.</p>
            </div>
            <div class="card">
                <h3>hashCode()</h3>
                <p>Returns an integer hash value for an object. This value is used in hash-based collections like <code>HashMap</code>, <code>HashSet</code>, and <code>Hashtable</code> to determine where to store and retrieve objects.</p>
            </div>
        </div>
    </section>

    <section id="equals-method">
        <h2>üîç The equals() Method</h2>

        <h3>Default Implementation</h3>
        <p>In the <code>Object</code> class, <code>equals()</code> is defined as:</p>
        <pre><code>public boolean equals(Object obj) {
    return (this == obj);
}</code></pre>
        <p>This simply checks if the references point to the same object in memory.</p>

        <h3>The equals() Contract</h3>
        <p>When overriding <code>equals()</code>, you must adhere to these five rules:</p>

        <div class="card">
            <ol>
                <li><strong>Reflexive:</strong> For any non-null reference value <code>x</code>, <code>x.equals(x)</code> should return <code>true</code>.</li>
                <li><strong>Symmetric:</strong> For any non-null reference values <code>x</code> and <code>y</code>, <code>x.equals(y)</code> should return <code>true</code> if and only if <code>y.equals(x)</code> returns <code>true</code>.</li>
                <li><strong>Transitive:</strong> For any non-null reference values <code>x</code>, <code>y</code>, and <code>z</code>, if <code>x.equals(y)</code> returns <code>true</code> and <code>y.equals(z)</code> returns <code>true</code>, then <code>x.equals(z)</code> should return <code>true</code>.</li>
                <li><strong>Consistent:</strong> For any non-null reference values <code>x</code> and <code>y</code>, multiple invocations of <code>x.equals(y)</code> should consistently return <code>true</code> or consistently return <code>false</code>, provided no information used in equals comparisons on the objects is modified.</li>
                <li><strong>Non-nullity:</strong> For any non-null reference value <code>x</code>, <code>x.equals(null)</code> should return <code>false</code>.</li>
            </ol>
        </div>

        <div class="note">
            <p><strong>Note:</strong> Violating any of these rules can lead to unpredictable behavior, especially when using collections like <code>HashSet</code> or <code>HashMap</code>.</p>
        </div>
    </section>

    <section id="hashcode-method">
        <h2>üßÆ The hashCode() Method</h2>

        <h3>Purpose of hashCode()</h3>
        <p>The <code>hashCode()</code> method returns an integer value that represents the state of an object. It's primarily used by hash-based collections to:</p>
        <ul>
            <li>Determine the bucket location where the object should be stored</li>
            <li>Quickly locate objects during lookup operations</li>
        </ul>

        <h3>The hashCode() Contract</h3>
        <div class="card">
            <ol>
                <li><strong>Consistency:</strong> During a single execution of an application, the <code>hashCode()</code> method must consistently return the same integer value whenever it is invoked on the same object, provided no information used in equals comparisons is modified.</li>
                <li><strong>Equality consistency:</strong> If two objects are equal according to the <code>equals(Object)</code> method, then calling <code>hashCode()</code> on each of the two objects must produce the same integer result.</li>
                <li><strong>Collision awareness:</strong> It is not required that if two objects are unequal according to the <code>equals(Object)</code> method, then calling <code>hashCode()</code> on each of the two objects must produce distinct results. However, producing distinct results for unequal objects may improve the performance of hash tables.</li>
            </ol>
        </div>

        <div class="note">
            <p><strong>Note:</strong> A good <code>hashCode()</code> implementation should distribute hash values uniformly to minimize collisions.</p>
        </div>
    </section>

    <section id="relationship">
        <h2>üîó Relationship Between equals() and hashCode()</h2>

        <div class="warning">
            <h3>The Critical Rule</h3>
            <p>If two objects are equal according to the <code>equals(Object)</code> method, then calling the <code>hashCode()</code> method on each of the two objects must produce the same integer result.</p>
        </div>

        <p>The reverse is not required to be true. Two objects with the same hash code are not required to be equal. However, producing distinct hash codes for unequal objects can improve hash table performance.</p>

        <div class="example">
            <div class="example-title">Why This Relationship Matters</div>
            <p>Consider what happens when you add objects to a <code>HashSet</code>:</p>
            <ol>
                <li>The <code>hashCode()</code> method is called to determine which bucket the object should go into.</li>
                <li>If objects already exist in that bucket, the <code>equals()</code> method is used to check if the object is a duplicate.</li>
            </ol>
            <p>If <code>equals()</code> says objects are equal but <code>hashCode()</code> returns different values, the objects might end up in different buckets, violating the set property of no duplicates.</p>
        </div>
    </section>

    <section id="implementation">
        <h2>‚úÖ Proper Implementation</h2>

        <div class="card">
            <h3>Steps for Proper Implementation</h3>
            <ol>
                <li>Decide which fields are significant for equality.</li>
                <li>Implement <code>equals()</code> method using these fields.</li>
                <li>Implement <code>hashCode()</code> method using the same fields.</li>
                <li>Test your implementation with hash-based collections.</li>
            </ol>
        </div>

        <h3>Manual Implementation Example</h3>
        <pre><code>public class Employee {
    private final String id;
    private final String name;
    private final String department;
    private int salary; // Mutable field

    public Employee(String id, String name, String department, int salary) {
        this.id = id;
        this.name = name;
        this.department = department;
        this.salary = salary;
    }

    @Override
    public boolean equals(Object o) {
        // 1. Reference check
        if (this == o) return true;

        // 2. Null check
        if (o == null) return false;

        // 3. Type check
        if (getClass() != o.getClass()) return false;

        // 4. Cast
        Employee employee = (Employee) o;

        // 5. Field comparison (using only immutable fields or those significant for identity)
        return Objects.equals(id, employee.id) &&
               Objects.equals(name, employee.name) &&
               Objects.equals(department, employee.department);
        // Note: salary is mutable and excluded from equals/hashCode
    }

    @Override
    public int hashCode() {
        // Use the same fields as in equals()
        return Objects.hash(id, name, department);
    }
}</code></pre>

        <h3>Using Objects Utility Methods</h3>
        <p>Since Java 7, you can use <code>Objects.equals()</code> and <code>Objects.hash()</code> to simplify your implementations:</p>
        <pre><code>@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Person person = (Person) o;
    return Objects.equals(id, person.id) &&
           Objects.equals(name, person.name) &&
           Objects.equals(department, person.department);
}

@Override
public int hashCode() {
    return Objects.hash(id, name, department);
}</code></pre>
    </section>

    <section id="collections">
        <h2>üì¶ Impact on Collections</h2>

        <div class="two-columns">
            <div class="card">
                <h3>HashMap/HashSet</h3>
                <p>These use <code>hashCode()</code> to determine the bucket and <code>equals()</code> to check for duplicates. If implemented incorrectly, you may see:</p>
                <ul>
                    <li>Duplicate entries</li>
                    <li>Inability to find objects that should be there</li>
                    <li>Performance degradation</li>
                </ul>
            </div>
            <div class="card">
                <h3>TreeMap/TreeSet</h3>
                <p>These use <code>Comparable</code> or <code>Comparator</code> rather than <code>equals()</code> and <code>hashCode()</code>, but maintaining consistency between these methods is important.</p>
            </div>
        </div>

        <div class="example">
            <div class="example-title">HashSet Example</div>
            <pre><code>Set&lt;Employee&gt; employees = new HashSet&lt;&gt;();
employees.add(new Employee("E123", "Alice", "Engineering", 90000));
employees.add(new Employee("E123", "Alice", "Engineering", 95000)); // Same id, name, department

System.out.println(employees.size()); // Should output 1 if equals/hashCode use only id, name, department</code></pre>
        </div>

        <div class="example">
            <div class="example-title">HashMap Example</div>
            <pre><code>Map&lt;Employee, String&gt; employeePerformance = new HashMap&lt;&gt;();
Employee alice = new Employee("E123", "Alice", "Engineering", 90000);
employeePerformance.put(alice, "Excellent");

alice.setSalary(95000); // Modify mutable field (not part of equals/hashCode)
String performance = employeePerformance.get(alice); // Should still find "Excellent"

System.out.println(performance); // Output: Excellent</code></pre>
        </div>
    </section>

    <section id="common-mistakes">
        <h2>‚ö†Ô∏è Common Mistakes</h2>

        <div class="card">
            <h3>1. Overriding equals() without hashCode()</h3>
            <p>This violates the contract between the two methods and leads to unexpected behavior in hash-based collections.</p>
            <div class="example-title">Result:</div>
            <p>Objects that are "equal" might be treated as different in hash-based collections like <code>HashSet</code> and <code>HashMap</code>.</p>
        </div>

        <div class="card">
            <h3>2. Including Mutable Fields</h3>
            <p>If you include mutable fields in your <code>equals()</code> and <code>hashCode()</code> implementations, objects in hash-based collections can "disappear" when those fields change.</p>
            <div class="example-title">Result:</div>
            <p>After adding an object to a <code>HashMap</code> and changing a field used in <code>hashCode()</code>, you may not be able to retrieve the object even though it's still in the map.</p>
        </div>

        <div class="card">
            <h3>3. Using Wrong Type Comparison</h3>
            <p>Using <code>instanceof</code> instead of <code>getClass()</code> can violate the symmetry principle if subclasses are involved.</p>
            <div class="example-title">Example:</div>
            <pre><code>// Incorrect
if (o instanceof Person) // Problem with inheritance!

// Correct (if Person is not designed for inheritance)
if (o == null || getClass() != o.getClass())</code></pre>
        </div>

        <div class="card">
            <h3>4. Forgetting Null Checks</h3>
            <p>Not checking for null before accessing fields can lead to <code>NullPointerException</code>.</p>
            <div class="example-title">Solution:</div>
            <p>Use <code>Objects.equals()</code> which handles null values safely.</p>
        </div>
    </section>

    <section id="best-practices">
        <h2>üß† Best Practices</h2>

        <div class="card">
            <h3>1. Always Override Both Methods</h3>
            <p>If you override <code>equals()</code>, always override <code>hashCode()</code> as well.</p>
        </div>

        <div class="card">
            <h3>2. Use Immutable Fields</h3>
            <p>Prefer using immutable fields for <code>equals()</code> and <code>hashCode()</code> to avoid objects "disappearing" in hash-based collections.</p>
        </div>

        <div class="card">
            <h3>3. Use Objects Utility Methods</h3>
            <p>Use <code>Objects.equals()</code> for null-safe equality checks and <code>Objects.hash()</code> for generating hash codes.</p>
        </div>

        <div class="card">
            <h3>4. Use IDE Generation Tools</h3>
            <p>Most modern IDEs can generate correct <code>equals()</code> and <code>hashCode()</code> methods for you.</p>
            <ul>
                <li>IntelliJ IDEA: Right-click ‚Üí Generate ‚Üí equals() and hashCode()</li>
                <li>Eclipse: Right-click ‚Üí Source ‚Üí Generate hashCode() and equals()</li>
                <li>NetBeans: Right-click ‚Üí Insert Code ‚Üí equals() and hashCode()</li>
            </ul>
        </div>

        <div class="card">
            <h3>5. Consider Using Lombok</h3>
            <p>The Lombok library provides annotations like <code>@EqualsAndHashCode</code> that automatically generate these methods.</p>
            <pre><code>import lombok.EqualsAndHashCode;

@EqualsAndHashCode(of = {"id", "name", "department"}) // Specify which fields to use
public class Employee {
    private final String id;
    private final String name;
    private final String department;
    private int salary; // Excluded from equals/hashCode

    // Constructor and methods...
}</code></pre>
        </div>
    </section>

    <section id="interview-questions">
        <h2>üìù Interview Questions & Answers</h2>

        <div class="faq">
            <div class="question">1. What happens if you override equals() but not hashCode()?</div>
            <div class="answer">
                <p>If you override <code>equals()</code> but not <code>hashCode()</code>, you violate the contract that equal objects must have equal hash codes. This can cause:</p>
                <ul>
                    <li>Objects that are equal according to <code>equals()</code> might have different hash codes</li>
                    <li>In hash-based collections like <code>HashMap</code> and <code>HashSet</code>, lookups may fail even when equal objects exist in the collection</li>
                    <li>Collections that should contain no duplicates (like <code>HashSet</code>) might contain what you would consider duplicate elements</li>
                </ul>
                <p>For example, if two <code>Person</code> objects with the same name and age are considered equal by your <code>equals()</code> method but have different hash codes, they would be stored in different buckets in a <code>HashSet</code>, resulting in what appears to be duplicate entries.</p>
            </div>
        </div>

        <div class="faq">
            <div class="question">2. Why should mutable fields generally be avoided in equals() and hashCode()?</div>
            <div class="answer">
                <p>Mutable fields should generally be avoided in <code>equals()</code> and <code>hashCode()</code> implementations because:</p>
                <ul>
                    <li>If an object's hash code changes after being added to a hash-based collection, the collection may no longer be able to find that object</li>
                    <li>This violates the consistency requirement of <code>hashCode()</code></li>
                    <li>It can lead to "lost" objects in collections ‚Äî they're still there, but you can't find or remove them</li>
                </ul>
                <p>A better approach is to use only immutable fields or those that represent the object's identity and are unlikely to change during the object's lifecycle.</p>
            </div>
        </div>

        <div class="faq">
            <div class="question">3. How are hash collisions handled in a HashMap?</div>
            <div class="answer">
                <p>When a hash collision occurs in a <code>HashMap</code> (when two different keys have the same hash code or when different hash codes map to the same bucket):</p>
                <ol>
                    <li><strong>Java 8 and later:</strong> The HashMap uses a balanced tree (Red-Black Tree) instead of a linked list when the number of elements in a bucket exceeds a certain threshold (8 by default). This improves worst-case performance from O(n) to O(log n).</li>
                    <li><strong>Before Java 8:</strong> Each bucket contained a linked list of entries with the same hash. The time complexity for lookups in case of many collisions was O(n).</li>
                </ol>
                <p>In both cases, after finding the correct bucket using <code>hashCode()</code>, the <code>equals()</code> method is used to find the exact entry in the bucket.</p>
            </div>
        </div>

        <div class="faq">
            <div class="question">4. What's the difference between == and equals()?</div>
            <div class="answer">
                <p>The key differences are:</p>
                <ul>
                    <li><code>==</code> operator checks for reference equality (if two references point to the exact same object in memory)</li>
                    <li><code>equals()</code> method checks for logical equivalence, which is defined by the class</li>
                    <li>For primitive types, <code>==</code> compares their values</li>
                    <li>For reference types, <code>==</code> compares memory addresses</li>
                    <li>The default <code>equals()</code> implementation in <code>Object</code> class uses <code>==</code>, but many classes like <code>String</code>, <code>Integer</code>, etc. override it to compare content</li>
                </ul>
                <pre><code>String a = new String("hello");
String b = new String("hello");

// Different objects in memory
System.out.println(a == b);      // false

// Same content
System.out.println(a.equals(b)); // true</code></pre>
            </div>
        </div>

        <div class="faq">
            <div class="question">5. Should equals() use instanceof or getClass() for type checking?</div>
            <div class="answer">
                <p>It depends on your class design:</p>
                <ul>
                    <li><strong>getClass() approach:</strong> Use when following the Liskov Substitution Principle strictly and when equality should be based on exact class types. This is appropriate when subclasses may have additional significant fields.</li>
                    <pre><code>if (o == null || getClass() != o.getClass()) return false;</code></pre>
                    <li><strong>instanceof approach:</strong> Use when implementing an inheritance relationship where subclasses can be equal to parent classes. This is often used in abstract base classes that define a common equality contract for all subclasses.</li>
                    <pre><code>if (!(o instanceof Person)) return false;</code></pre>
                </ul>
                <p>Most often, <code>getClass()</code> is the safer choice to ensure symmetry of the <code>equals()</code> method across inheritance hierarchies. If using <code>instanceof</code>, you need to be careful about maintaining the symmetry contract of <code>equals()</code>.</p>
            </div>
        </div>

        <div class="faq">
            <div class="question">6. How does using mutable fields in hashCode() affect Collections behavior?</div>
            <div class="answer">
                <p>Using mutable fields in <code>hashCode()</code> can cause serious problems:</p>
                <ol>
                    <li><strong>Object "disappearance":</strong> If an object is added to a <code>HashMap</code> or <code>HashSet</code> and then a field used in <code>hashCode()</code> changes, the collection won't be able to find the object again because it's looking in the wrong bucket.</li>
                    <li><strong>Duplicate entries:</strong> Changing a field used in <code>hashCode()</code> can allow you to add what appears to be the same object multiple times to a <code>HashSet</code>.</li>
                    <li><strong>Memory leaks:</strong> Unable to remove objects that have changed their hash code, leading to potential memory leaks.</li>
                </ol>
                <pre><code>// Demonstrating the problem
Set&lt;Person&gt; set = new HashSet&lt;&gt;();
Person p = new Person("Alice", 30);
set.add(p);

// If age is used in hashCode() and we change it:
p.setAge(31);

// Now the set contains p, but...
System.out.println(set.contains(p)); // false
System.out.println(set.size());      // 1 (object still there but can't be found or removed)</code></pre>
            </div>
        </div>

        <div class="faq">
            <div class="question">7. How does the hashCode() contract relate to performance?</div>
            <div class="answer">
                <p>The <code>hashCode()</code> contract requires that equal objects have equal hash codes but doesn't require unequal objects to have different hash codes. However, the performance of hash-based collections is directly related to how well your <code>hashCode()</code> method distributes objects:</p>
                <ul>
                    <li><strong>Good distribution:</strong> Hash codes spread objects evenly across buckets, resulting in O(1) average performance for <code>HashMap</code> and <code>HashSet</code> operations.</li>
                    <li><strong>Poor distribution:</strong> Many objects hash to the same bucket (many collisions), degrading performance toward O(log n) or O(n), depending on Java version.</li>
                </ul>
                <p>An extreme example of poor distribution would be returning a constant value from <code>hashCode()</code>:</p>
                <pre><code>@Override
public int hashCode() {
    return 42; // Poor implementation: all objects hash to the same bucket
}</code></pre>
                <p>This would effectively turn a <code>HashMap</code> into a linked list or tree (depending on Java version), eliminating the performance benefits of using a hash-based collection.</p>
            </div>
        </div>

        <div class="faq">
            <div class="question">8. How would you implement equals() and hashCode() for a class with array fields?</div>
            <div class="answer">
                <p>Array fields require special handling because arrays don't override <code>equals()</code> and <code>hashCode()</code> methods properly:</p>
                <pre><code>public class ArrayContainer {
    private final int[] numbers;
    private final String name;

    public ArrayContainer(String name, int[] numbers) {
        this.name = name;
        this.numbers = numbers;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        ArrayContainer that = (ArrayContainer) o;

        // Use Arrays.equals for array comparison
        return Objects.equals(name, that.name) &&
               Arrays.equals(numbers, that.numbers);
    }

    @Override
    public int hashCode() {
        // Use Arrays.hashCode for arrays
        int result = Objects.hashCode(name);
        result = 31 * result + Arrays.hashCode(numbers);
        return result;

        // Alternatively with Java 7+:
        // return Objects.hash(name, Arrays.hashCode(numbers));
    }
}</code></pre>
                <p>For multi-dimensional arrays, use the corresponding <code>Arrays.deepEquals()</code> and <code>Arrays.deepHashCode()</code> methods.</p>
            </div>
        </div>

        <div class="faq">
            <div class="question">9. How does the equals() method handle null values?</div>
            <div class="answer">
                <p>The default <code>equals()</code> method in the <code>Object</code> class doesn't handle null values specially, but when overriding <code>equals()</code>, you need to:</p>
                <ol>
                    <li>Check if the parameter is null (as per the contract, <code>x.equals(null)</code> should return <code>false</code>)</li>
                    <li>Safely compare potentially null fields</li>
                </ol>
                <p>The safest approach is to use <code>Objects.equals()</code> which handles nulls properly:</p>
                <pre><code>// Safe null handling
if (Objects.equals(name, other.name)) {
    // Fields are either both null or have the same value
}

// Instead of:
if (name == null ? other.name == null : name.equals(other.name)) {
    // More verbose but equivalent
}</code></pre>
                <p>This prevents <code>NullPointerException</code> when comparing fields that might be null.</p>
            </div>
        </div>

        <div class="faq">
            <div class="question">10. What's the role of equals() and hashCode() in inheritance hierarchies?</div>
            <div class="answer">
                <p>In inheritance hierarchies, <code>equals()</code> and <code>hashCode()</code> can be tricky to implement correctly:</p>
                <ul>
                    <li><strong>Challenge:</strong> Maintaining symmetry and transitivity across subclasses that may add fields</li>
                    <li><strong>Composition over inheritance:</strong> Often preferred to avoid these issues</li>
                    <li><strong>Final classes:</strong> For classes not designed for inheritance, mark them <code>final</code></li>
                </ul>
                <p>There are two main approaches:</p>
                <ol>
                    <li><strong>Use <code>getClass()</code> check:</strong> Ensures objects are only equal if they're of the exact same class
                        <pre><code>if (o == null || getClass() != o.getClass()) return false;</code></pre>
                    </li>
                    <li><strong>Define an abstract <code>canEqual()</code> method:</strong> This is Josh Bloch's approach that maintains symmetry
                        <pre><code>@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Person)) return false;
    Person person = (Person) o;

    // Allow subclasses to opt into equality comparisons
    if (!person.canEqual(this)) return false;

    return age == person.age && Objects.equals(name, person.name);
}

protected boolean canEqual(Object other) {
    return other instanceof Person;
}</code></pre>
                    </li>
                </ol>
                <p>Subclasses would override both <code>equals()</code> and <code>canEqual()</code> to maintain proper behavior.</p>
            </div>
        </div>

        <div class="faq">
            <div class="question">11. Can you override only hashCode() without overriding equals()?</div>
            <div class="answer">
                <p>While technically possible, overriding only <code>hashCode()</code> without overriding <code>equals()</code> is generally a bad idea because:</p>
                <ul>
                    <li>It may break the contract that equal objects must have equal hash codes</li>
                    <li>It creates confusing behavior when objects are used in collections</li>
                    <li>It makes your code less maintainable and more error-prone</li>
                </ul>
                <p>In practice, these methods should always be overridden together. Any time you override one, override the other.</p>
            </div>
        </div>

        <div class="faq">
            <div class="question">12. How do equals() and hashCode() affect performance in large collections?</div>
            <div class="answer">
                <p>In large collections, the implementation of <code>equals()</code> and <code>hashCode()</code> can significantly impact performance:</p>
                <ul>
                    <li><strong>hashCode() performance:</strong> Should be fast to compute as it's called frequently during collection operations</li>
                    <li><strong>equals() performance:</strong> Should be optimized as it's called to resolve collisions</li>
                    <li><strong>Field ordering:</strong> Put fields most likely to differ first in <code>equals()</code> to short-circuit comparisons faster</li>
                </ul>
                <p>Performance optimizations:</p>
                <pre><code>@Override
public boolean equals(Object o) {
    if (this == o) return true; // Fast reference check first
    if (o == null || getClass() != o.getClass()) return false;

    Person person = (Person) o;

    // Check most distinguishing fields first to fail fast
    if (id != person.id) return false; // Primitive comparison is fast
    if (!Objects.equals(email, person.email)) return false; // Likely unique

    // Only then check more expensive or less distinctive fields
    return Objects.equals(name, person.name) &&
           Objects.equals(addressDeepCopy, person.addressDeepCopy);
}</code></pre>
                <p>For <code>hashCode()</code>, use fields that provide good distribution but are fast to compute.</p>
            </div>
        </div>

        <div class="faq">
            <div class="question">13. What is the impact of a poor hashCode() implementation on HashMap performance?</div>
            <div class="answer">
                <p>A poor <code>hashCode()</code> implementation can severely degrade <code>HashMap</code> performance:</p>
                <ul>
                    <li><strong>Worst case:</strong> If all objects hash to the same bucket, lookup operations degrade from O(1) to O(log n) or even O(n)</li>
                    <li><strong>Memory usage:</strong> Poorly distributed hash codes can cause inefficient use of the allocated bucket array</li>
                    <li><strong>Resizing operations:</strong> More frequent resizing operations due to long chains in some buckets</li>
                </ul>
                <p>Performance difference example:</p>
                <pre><code>// Good distribution: operations stay close to O(1)
map.get(key); // Fast, usually constant time

// Poor distribution: many objects in same bucket
map.get(key); // Could be much slower, approaching O(n)</code></pre>
                <p>The difference becomes more pronounced as the collection grows larger.</p>
            </div>
        </div>

        <div class="faq">
            <div class="question">14. What is the relationship between equals() and the Comparable interface?</div>
            <div class="answer">
                <p>While <code>equals()</code> and <code>Comparable.compareTo()</code> are separate, they should be consistent:</p>
                <ul>
                    <li>If <code>x.equals(y)</code> is true, then <code>x.compareTo(y)</code> should return 0</li>
                    <li>If <code>x.compareTo(y)</code> returns 0, ideally <code>x.equals(y)</code> should be true (though not strictly required)</li>
                </ul>
                <p>Inconsistency between these methods can lead to unexpected behavior in collections:</p>
                <pre><code>// If these are inconsistent:
TreeSet&lt;MyClass&gt; treeSet = new TreeSet&lt;&gt;();
HashSet&lt;MyClass&gt; hashSet = new HashSet&lt;&gt;();

// They might treat "equivalent" objects differently
treeSet.add(obj1);
treeSet.add(obj2); // Might not add if compareTo returns 0
hashSet.add(obj1);
hashSet.add(obj2); // Might add if equals returns false</code></pre>
                <p>For best results, ensure that <code>compareTo</code> and <code>equals</code> use the same logic for determining equality.</p>
            </div>
        </div>

        <div class="faq">
            <div class="question">15. How does String implement equals() and hashCode()?</div>
            <div class="answer">
                <p>The <code>String</code> class is a good example of proper <code>equals()</code> and <code>hashCode()</code> implementation:</p>
                <ul>
                    <li><code>equals()</code> compares the content (characters) of the strings, not their references</li>
                    <li><code>hashCode()</code> is computed based on the content, ensuring equal strings have equal hash codes</li>
                </ul>
                <p>String's <code>hashCode()</code> implementation uses a formula:</p>
                <pre><code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code></pre>
                <p>Where s[i] is the ith character of the string, n is the length, and ^ indicates exponentiation.</p>
                <p>String also caches its hash code after first computation for performance, since Strings are immutable:</p>
                <pre><code>public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        // Calculate hash code
        hash = h = ...
    }
    return h;
}</code></pre>
                <p>This makes repeated <code>hashCode()</code> calls on the same String very efficient.</p>
            </div>
        </div>
    </section>

    <section id="code-examples">
        <h2>üíª Code Examples</h2>

        <div class="card">
            <h3>Basic equals() and hashCode() Example</h3>
            <pre><code>public class Student {
    private final int id;
    private final String name;
    private double gpa; // Mutable field, excluded from equals/hashCode

    public Student(int id, String name, double gpa) {
        this.id = id;
        this.name = name;
        this.gpa = gpa;
    }

    // Getters and setters...

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return id == student.id &&
               Objects.equals(name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }
}</code></pre>
        </div>

        <div class="card">
            <h3>Dealing with Arrays</h3>
            <pre><code>public class Matrix {
    private final int[][] data;
    private final String name;

    public Matrix(String name, int[][] data) {
        this.name = name;
        this.data = data;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Matrix matrix = (Matrix) o;
        return Objects.equals(name, matrix.name) &&
               Arrays.deepEquals(data, matrix.data);
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + Arrays.deepHashCode(data);
        return result;
    }
}</code></pre>
        </div>

        <div class="card">
            <h3>Inherited Class Example</h3>
            <pre><code>public class Person {
    protected final String name;
    protected final LocalDate birthDate;

    public Person(String name, LocalDate birthDate) {
        this.name = name;
        this.birthDate = birthDate;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return Objects.equals(name, person.name) &&
               Objects.equals(birthDate, person.birthDate);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, birthDate);
    }
}

public class Employee extends Person {
    private final String employeeId;
    private String department; // Mutable, but part of equality

    public Employee(String name, LocalDate birthDate, String employeeId, String department) {
        super(name, birthDate);
        this.employeeId = employeeId;
        this.department = department;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Employee employee = (Employee) o;
        return Objects.equals(employeeId, employee.employeeId) &&
               Objects.equals(department, employee.department);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), employeeId, department);
    }
}</code></pre>
        </div>

        <div class="card">
            <h3>Impact on HashMap Example</h3>
            <pre><code>public static void main(String[] args) {
    // Create a map with our Person objects as keys
    Map&lt;Person, String&gt; people = new HashMap&lt;&gt;();

    // Create two people with same data
    Person john1 = new Person("John", LocalDate.of(1990, 5, 15));
    Person john2 = new Person("John", LocalDate.of(1990, 5, 15));

    // Add to the map
    people.put(john1, "Software Engineer");

    // Test the behavior
    System.out.println("john1.equals(john2): " + john1.equals(john2));
    System.out.println("hashCodes equal: " + (john1.hashCode() == john2.hashCode()));
    System.out.println("Can find john2 in map: " + people.containsKey(john2));
    System.out.println("John's job: " + people.get(john2));
}</code></pre>
            <p>With a proper implementation, the output would be:</p>
            <pre><code>john1.equals(john2): true
hashCodes equal: true
Can find john2 in map: true
John's job: Software Engineer</code></pre>
            <p>With a broken implementation (e.g., overriding only <code>equals()</code>), it might be:</p>
            <pre><code>john1.equals(john2): true
hashCodes equal: false
Can find john2 in map: false
John's job: null</code></pre>
        </div>
    </section>

    <div class="success">
        <h3>Summary</h3>
        <p>Understanding <code>equals()</code> and <code>hashCode()</code> is essential for any Java developer. Remember these key points:</p>
        <ul>
            <li>Always override both methods together</li>
            <li>Follow the contracts defined for each method</li>
            <li>Use immutable fields when possible</li>
            <li>Leverage IDE tools and utility methods like <code>Objects.equals()</code> and <code>Objects.hash()</code></li>
            <li>Test your implementations with hash-based collections</li>
        </ul>
        <p>Properly implementing these methods ensures your objects behave correctly in collections and comparison operations.</p>
    </div>

    <script>
        // Optional: Add click behavior to show/hide answers
        document.querySelectorAll('.question').forEach(question => {
            question.addEventListener('click', () => {
                const answer = question.nextElementSibling;
                answer.style.display = answer.style.display === 'none' ? 'block' : 'none';
            });
        });
    </script>
</div>
</body>
</html>