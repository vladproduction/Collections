<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Guide to Java Generics</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; padding: 20px; background-color: #f4f4f4; }
        h1, h2, h3 { color: #333; }
        code { background-color: #eee; padding: 2px 4px; border-radius: 4px; }
        pre { background-color: #eee; padding: 10px; border-radius: 4px; overflow-x: auto; }
        section { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    </style>
</head>
<body>

<h1>Comprehensive Guide to Java Generics</h1>

<section>
    <h2>1. What are Generics?</h2>
    <p>Generics allow classes, interfaces, and methods to operate on typed parameters. They provide compile-time type safety and eliminate the need for type casting.</p>
    <pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add("Hello");
String s = list.get(0); // No cast needed</code></pre>
</section>

<section>
    <h2>2. Generic Classes</h2>
    <pre><code>public class Box&lt;T&gt; {
    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}</code></pre>
    <p>Usage:</p>
    <pre><code>Box&lt;Integer&gt; intBox = new Box&lt;&gt;();
intBox.set(100);
Integer value = intBox.get();</code></pre>
</section>

<section>
    <h2>3. Generic Methods</h2>
    <pre><code>public class Util {
    public static &lt;T&gt; void printArray(T[] array) {
        for (T item : array) {
            System.out.println(item);
        }
    }
}</code></pre>
    <p>Usage:</p>
    <pre><code>String[] names = {"Alice", "Bob"};
Util.printArray(names);</code></pre>
</section>

<section>
    <h2>4. Bounded Type Parameters</h2>
    <pre><code>public class NumberBox&lt;T extends Number&gt; {
    private T number;

    public NumberBox(T number) {
        this.number = number;
    }

    public double doubleValue() {
        return number.doubleValue();
    }
}</code></pre>
</section>

<section>
    <h2>5. Wildcards</h2>
    <p>Wildcards allow flexibility in method parameters:</p>
    <ul>
        <li><code>? extends T</code>: an unknown subtype of T</li>
        <li><code>? super T</code>: an unknown supertype of T</li>
        <li><code>?</code>: unknown type</li>
    </ul>
    <pre><code>public static void printList(List&lt;?&gt; list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}</code></pre>
</section>

<section>
    <h2>6. Generic Interfaces</h2>
    <pre><code>public interface Storage&lt;T&gt; {
    void add(T item);
    T get(int index);
}</code></pre>
</section>

<section>
    <h2>7. Type Inference and Diamond Operator</h2>
    <pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(); // type inferred</code></pre>
</section>

<section>
    <h2>8. Common Pitfalls</h2>
    <ul>
        <li>Cannot use primitive types: <code>Box&lt;int&gt;</code> is invalid; use <code>Box&lt;Integer&gt;</code>.</li>
        <li>Type erasure removes generic type info at runtime.</li>
        <li>Cannot create generic arrays: <code>new T[10]</code> is illegal.</li>
    </ul>
</section>

<section>
    <h2>9. Real-World Use Case</h2>
    <p>Java Collections API uses generics extensively:</p>
    <pre><code>Map&lt;String, Integer&gt; wordCounts = new HashMap&lt;&gt;();</code></pre>
</section>

<section>
    <h2>10. Summary</h2>
    <p>Generics bring strong type safety, reduce casting, and improve code reusability. Mastering them is essential for clean, scalable Java code.</p>
</section>

</body>
</html>