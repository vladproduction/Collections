<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HashMap Interview Preparation Review</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        h1, h2 {
            color: #2E86C1;
        }
        pre {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 8px;
            overflow-x: auto;
        }
        ul {
            margin-top: 0;
        }
    </style>
</head>
<body>
<h1>HashMap Interview Preparation Review</h1>

<h2>1. Overview</h2>
<p>
    HashMap is a data structure that implements the <strong>Map</strong> interface, storing key-value pairs.
    It allows efficient retrieval, insertion, and deletion of elements, typically with <strong>O(1)</strong> time complexity.
</p>

<h2>2. Key Concepts</h2>
<ul>
    <li><strong>Hashing:</strong> Converts keys into hash codes to determine index in the underlying array.</li>
    <li><strong>Bucket:</strong> Each slot in the array holds a bucket (linked list or tree) of entries with the same hash code.</li>
    <li><strong>Handling Collisions:</strong> When multiple keys hash to the same index, they are stored in a chain (linked list) or a balanced tree.</li>
    <li><strong>Resizing:</strong> HashMap dynamically resizes (rehashes) when load factor exceeds a threshold to maintain efficiency.</li>
</ul>

<h2>3. Common Operations</h2>
<ul>
    <li><strong>Put(key, value):</strong> Insert or update key-value pair.</li>
    <li><strong>Get(key):</strong> Retrieve value associated with the key.</li>
    <li><strong>Remove(key):</strong> Delete the key-value pair.</li>
    <li><strong>ContainsKey(key):</strong> Check if key exists.</li>
    <li><strong>Size():</strong> Return number of stored entries.</li>
    <li><strong>Clear():</strong> Remove all entries.</li>
</ul>

<h2>4. HashMap Internals</h2>
<p>
    HashMap uses an array of buckets, where each bucket contains a linked list or tree of entries (key-value pairs).
    The index is computed as <code>hash(key) & (array.length - 1)</code>.
    When collisions happen, entries are added to the chain or converted to a tree if a threshold is reached.
</p>

<h2>5. Important Points</h2>
<ul>
    <li><strong>Hash Function:</strong> Must uniformly distribute keys to avoid collisions.</li>
    <li><strong>Collision Handling:</strong> Separate chaining (linked list/tree) or open addressing (less common in Java HashMaps).</li>
    <li><strong>Resizing:</strong> Rehash occurs when size exceeds load factor * capacity (default load factor is 0.75).</li>
    <li><strong>Thread Safety:</strong> HashMap is not synchronized; for thread-safe operation, use ConcurrentHashMap.</li>
    <li><strong>Order:</strong> HashMap does not maintain insertion order; for ordered maps, use LinkedHashMap.</li>
</ul>

<h2>6. Advantages</h2>
<ul>
    <li>Constant time performance for basic operations (average case).</li>
    <li>Efficient for lookup, insertion, and deletion.</li>
    <li>Flexible and dynamic size.</li>
</ul>

<h2>7. Disadvantages</h2>
<ul>
    <li>Performance degrades to O(n) in worst-case scenarios (many collisions).</li>
    <li>Not synchronized; needs external synchronization in multithreaded environments.</li>
    <li>Unpredictable iteration order.</li>
</ul>

<h2>8. Implementation Tips for Interviews</h2>
<ul>
    <li><strong>Understand Hashing Mechanics:</strong> Be clear on how hash codes are generated and used to compute indices. Demonstrate knowledge of <em>hashCode()</em> and <em>equals()</em> methods and their importance in key comparison.</li>
    <li><strong>Collision Resolution:</strong> Explain separate chaining (linked lists/trees) and how it manages hash collisions. Be ready to discuss rehashing and load factors.</li>
    <li><strong>Rehashing:</strong> Know when rehashing occurs (e.g., when load factor exceeds threshold) and how it affects performance and resizing.</li>
    <li><strong>Implement Core Operations:</strong> Be able to implement <em>put()</em>, <em>get()</em>, and <em>remove()</em> methods considering collision handling mechanisms.</li>
    <li><strong>Handling Null Keys/Values:</strong> Understand how Java's HashMap allows one null key and multiple null values, and how these are internally managed.</li>
    <li><strong>Thread Safety:</strong> Clarify that HashMap is not synchronized. Mention alternatives like <em>ConcurrentHashMap</em> for thread-safe operations.</li>
    <li><strong>Performance Awareness:</strong> Recognize that worst-case performance can degrade to O(n) when many collisions occur. Discuss strategies to minimize collisions, such as good hash functions and resizing.</li>
    <li><strong>Use Cases:</strong> Be prepared to discuss scenarios where HashMap is suitable and when to prefer other data structures like TreeMap or LinkedHashMap.</li>
    <li><strong>Code Style & Testing:</strong> Write clean, readable code with proper variable names. Consider edge cases, such as null keys and values, and test thoroughly.</li>
</ul>